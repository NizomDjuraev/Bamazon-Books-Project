<!DOCTYPE html>
<html>

<head>
    <title>Reflections</title>
</head>

<body>
    <h1>
        HW4 Reflection
    </h1>
    <h2>
        UI
    </h2>
    <p>For the authorization, I initially integrated it into only my UI. I setup it up so that its checking if the user
        is logged in and then
        making all author and book functionality accessible/visible. If the user isn't logged in, only the account page
        is accessible, allowing the user to log in. It prevents users from accessing the authors and books manually by
        either visiting the link directly or curling it with server side validation. This means theres both client side
        and server side validation. If the user tries accessing the page directly via the http link, they'll receive a
        blanks screen.
        <br>
        <br>
        I struggled with getting the navigation page to properly function when user is logged in. I had issues getting
        that to work properly by checking if the user was logged in and authorized. I setup a separate /authorize
        endpoint for this that returns a boolean. Nothing specific was difficult, I wasted time trying to resolve an
        issue when I had commented out my cookie-parser and another import causing silly problems for an hour.
    </p>

    <h2>
        Login Endpoint
    </h2>
    <p>Adding the logins and authorization to the back-end wasn't too complicated. I had some issues bringing over some
        of the
        workflow I setup in activity 4 since it covered the basics of this. The process was relatively smooth aside from
        some silly issues again. I setup the login and authorization for the 375 project for the most part so I was
        familiar with the flow and how it should be implemented. I also realized I had setup the 375 project and made it
        vulnerable to client side script attacks since the cookie was accessible by JS as well as not having the cookie
        hashed/hidden.
    </p>

</body>

<body>
    <h1>
        HW3 Reflection
    </h1>
    <h2>
        UI
    </h2>
    <p>For integrating my book editing and deletion, I thought it would make sense if the user could see the changes
        live, whether its a delete or an edit. I placed the edit and delete on the same page as the rest of my book
        elements. I also made the edit and delete forms into one, simplifying the process of changing existing books.
        The implementation of book editing wasn't bad, most of the logic was reused from my post request for
        adding the book. At first when I was reusing the form elements I had written, I forgot to separate the two
        states so it was copying the state from one set of fields to the other. It was a cool bug to visually see the
        effects of state complexity and how it can slip by, causing other problems. Implementing delete on my front-end
        was probably the easiest part of this.
        <br>
    </p>

    <h2>
        Material UI
    </h2>
    <p>Material UI was tricky to use when it required refactoring for some code. I kept running into errors, I decided
        to go with only styling components such as my buttons and the elements of my navigation bar. I ran into pitfalls
        when I would look at examples or stack overflow for errors. Some of the fixes were outdated and were on Material
        UI v4 and now its on v5.
    </p>

    <h2>
        PUT Endpoint
    </h2>
    <p>Adding the PUT endpoint itself was simple, the logic was similar to my post request. The experience from writing
        the POST endpoints did help make writing the PUT endpoint alot smoother. The tests on the other hand,
        AGGGHHHH. The tests just wouldn't pass no matter what changes I made. I got the sqlite contraint error, which
        from my
        hw1 comments I saw was from a book trying to exist without an accompanying author_id to match it. I manually
        entered an author and a book with matching id's to resolve this and it still wouldn't work. I spent a little
        over an hour trying to get my 3 PUT tests to work.
    </p>
</body>

<body>
    <h1>
        HW2 Reflection
    </h1>
    <h2>
        Design
    </h2>
    <p>Some changes I added to my back end were adding error checking that I didn't have a chance to complete as part of
        week 1. I added some checks for my post requests to my authors handler. The author must be valid; within 1 and
        25 characters, non-existing author name, no blank inputs either. Updated the route handlers from being
        redundant. Was previously /getauthors for a get request, now updated to
        /api/authors. I added ordering by name server side as well by name for authors to maintain alphabetical
        ordering. I also changed my ID columns for authors and books. I updated them to be
        autogenerated between 1 and 1000 and to prevent manually entering in ID's. I'm not sure why I decided last week
        to manually enter ID numbers but it was just bad decision making there.
        <br>
        <br>
        I may end up restructuring the back end more if the need arises. I found that I had to do that a couple of times
        in 375 for the final project when we needed to implement some new aspect.
        The UI of my forms is just input boxes that take in for author the author name and bio. For books, the forms
        take in author id, title, publication year, and genre. The user is met with a message if the button click
        interaction is successful or not and the reason why. I implemented searching by book title using SQL syntax
        LIKE. This let me do wildcard searches where it would filter the table by whatever is entered. I thought to
        update the table when the user is typing without having to click a search button, gives a smoother experience.
        For client side validation, I checked response status that was being sent over server side and reinforced that.
        I'm not sure if that counts as client side or is still the server side validation thats carried over. The pros
        of server side is that you wouldn't be sending in all the data to the client where it is exposed, similar to
        that smart hotub example you spoke about during class.
    </p>

    <h2>
        React
    </h2>
    <p>The experience initially was cumbersome. I've gotten used to plain javascript so getting accustomed to typescript
        and react was challenging. Utilizing the useEffect hook for updating the authors table and books was tricky but
        rewarding. That being said, once I got better accustomed to using hooks, they're very useful and
        powerful. My experience using types was mainly enforcing the author and book types. It wasn't very different
        from the back-end type enforcement in terms of my experience with it. Still just getting used to it. I didn't
        have to make many manual notations, having the types in my mind made sure to stay consistent with it. I didn't
        use any types at all or tried not to. Using SPA is pretty cool seeing the changes take place live
        without any page refreshing or clicking around. The process also seems much more expedited in comparison to 375.
        Although there was a learning curve to Javascript, which I think may have played a part in being slower in 375.
        React so far seems very powerful and I'm glad I'm taking this course.
    </p>
</body>

<body>
    <h1>HW1 Reflection</h1>
    <h2>Design</h2>
    <p>
        <b>How did you structure your API's requests and responses?</b><br>
        I structured my API's requests and responses by mostly following the RESTful principles. Each endpoint was
        designed to handle a specific type of request (GET, POST, DELETE) For example, the endpoint addtoauthors
        is
        used to add an authors to the authors table, while the endpoint getauthors is used to grab a list of all
        existing
        authors. I also made sure to include appropriate HTTP status codes and error messages in the responses to
        indicate the
        status.
    </p>
    <p>
        <b>How did you validate inputs, what restrictions did you choose, and why?</b><br>
        I validated inputs by checking that if there weren't any fields, which would return all. If there were entered
        fields
        such as genre for the book, I added some acceptable genres which could be chosen from. I also added restrictions
        such
        as being able to only add a book if the author exists.
    </p>
    <p>
        <b>What edge cases did you handle and how? What edge cases did you choose not to handle?</b><br>
        I handled edge cases such as ensuring that requests to non-existent endpoints returned a 404 error for endpoints
        that dont exist
        and that requests with invalid inputs returned a 400 Bad Request response.
    </p>
    <h2>Typescript</h2>
    <p>
        <b>Keep track of the bugs Typescript helped you catch and the ones it didn't catch.</b><br>
        Typescript helped me catch bugs such as incorrect types passed as function arguments and missing required fields
        in objects. It wasn't as helpful at first when getting used to Typescript, but became more useful as I kept
        using the same types and if I
        was missing a field.
    </p>
    <p>
        <b>What are some of the issues Typescript helped you prevent? What are some of the holes in the type
            system?</b><br>
        Typescript helped me prevent issues such as passing the wrong type of data to a function or accessing properties
        on an object that didn't exist.
    </p>
    <p>
        <b>What kinds of values did you struggle to type correctly? Are there any Typescript topics that are still
            confusing you?</b><br>
        I didn't necessarily struggle to type anything correctly after getting used to it. There aren't any topics right
        now but I'm
        sure there will be plenty that confuse me as I keep using typescript.
    </p>
    <h2>Testing</h2>
    <p>
        <b> What was your experience writing tests? Was it boring, soothing, rewarding? How did they affect your
            development process?</b>
        <br>
        Writing tests was awful. It was tedious and very error prone as there were many environment aspects I'm not used
        to and combining
        it all kept returning various errors while writing the tests. Googling around for help with the errors was
        helpful but overall
        the tests were boring and weren't very rewarding. I tested the functionality of my code as I was going through
        the functional steps
        and it was working fine. It hindered the development process in my opinion.
    </p>
    <p>
        <b>Did your tests help you find any bugs? If so, which ones?</b>
        <br>
        No my tests didn't help me find any bugs. I found I ran into more bugs related to writing the tests rather than
        finding
        bugs in my code.
    </p>
    <p>
        <b>How would you structure your testing differently in the future? What did you learn while testing?</b>
        <br>
        I'm not sure how to go about structuring the testing differently. Maybe being exposed to more testing would be
        beneficial,
        but I'm not really sure. I learned that testing is miserable and that if done right, its a useful tool.
    </p>
</body>



</html>